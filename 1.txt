let createTransformer = {
    password: async (value: any, data: any, context: HookContext) => {
        const { app, params } = context
        let options = { strategy: 'local', authentication: 'jwt' }//
        const { strategy = 'local' } = options
        //@ts-ignore
        const authService = app!.defaultAuthentication(options.authentication)
        const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]
        if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
            throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
        }
        let field = authService.configuration.local?.passwordField || 'password'
        let addHashedPassword = async (data: any) => {
            const password = get(data, field)
            if (password === undefined) {
                debug(`hook.data.${field} is undefined, not hashing password`)
                throw new BadRequest(`hook.data.${field} is undefined, not hashing password`)
            }
            const hashedPassword: string = await localStrategy.hashPassword(password, params)
            let d1 = set(cloneDeep(data), field, hashedPassword)
            return d1
        }
        let rData = await addHashedPassword(data)
        context.data = rData
    }
}


export default function hashPassword(field: string, options: HashPasswordOptions = {}) {
    if (!field) {
        throw new Error('The hashPassword hook requires a field name option')
    }
    return async (context: HookContext, next?: NextFunction) => {
        const { app, data, params } = context

        if (data !== undefined) {
            //@ts-ignore
            const authService = app!.defaultAuthentication(options.authentication)
            const { strategy = 'local' } = options

            if (!authService || typeof authService.getStrategies !== 'function') {
                throw new BadRequest('Could not find an authentication service to hash password')
            }

            const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]

            if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
                throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
            }

            const addHashedPassword = async (data: any) => {
                const password = get(data, field)

                if (password === undefined) {
                    debug(`hook.data.${field} is undefined, not hashing password`)
                    return data
                }

                const hashedPassword: string = await localStrategy.hashPassword(password, params)

                return set(cloneDeep(data), field, hashedPassword)
            }
            context.data = Array.isArray(data)
                ? await Promise.all(data.map(addHashedPassword))
                : await addHashedPassword(data)
        }
        if (typeof next === 'function') {
            return next()
        }
    }
}





 hooks(this, {
            create: [
                async function (context: HookContext, next) {
                    // console.log(Object.keys(context), '111')//
                    // const data1 = context.data
                    // console.log(data1, 'testData')//
                    const { app, params, data } = context
                    let options = { strategy: 'local', authentication: 'authentication' }//
                    const { strategy = 'local' } = options
                    //@ts-ignore
                    const authService = app!.defaultAuthentication(options.authentication)
                    const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]
                    if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
                        throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
                    }
                    let field = authService.configuration.local?.passwordField || 'password'
                    let addHashedPassword = async (data: any) => {
                        const password = get(data, field)
                        if (password === undefined) {
                            debug(`hook.data.${field} is undefined, not hashing password`)
                            throw new BadRequest(`hook.data.${field} is undefined, not hashing password`)
                        }
                        const hashedPassword: string = await localStrategy.hashPassword(password, params)
                        let d1 = set(cloneDeep(data), field, hashedPassword)
                        return d1
                    }
                    let rData = await addHashedPassword(data)
                    context.data = rData
                    await next()
                }
            ]
        })


        "dev": "nodemon --exec \"node --inspect-brk -r ts-node/register\" src/main_index.ts"


        // const params = context.params || {}
            // const provider = params.provider
            // if (provider) {
            //   let adadpter = params.adapter
            //   if (adadpter == null) {
            //     params.adapter = {}
            //     adadpter = params.adapter
            //   }
            //   let Model = adadpter.Model
            //   let oldModel = this.getOptions({}).Model
            //   if (Model == null) {
            //     let transaction = await oldModel.transaction()
            //     adadpter.Model = transaction
            //   }
            // }//

            //     let sql = `SELECT

    // 		c.*,
    //     CASE
    //         WHEN tc.constraint_type = 'PRIMARY KEY' THEN true
    //         ELSE false
    //     END AS is_primary_key
    // FROM
    //     information_schema.columns c
    // LEFT JOIN information_schema.key_column_usage kcu
    //     ON c.table_name = kcu.table_name
    //     AND c.column_name = kcu.column_name
    //     AND c.table_schema = kcu.table_schema
    // LEFT JOIN information_schema.table_constraints tc
    //     ON kcu.constraint_name = tc.constraint_name
    //     AND kcu.table_schema = tc.table_schema
    //     AND tc.constraint_type = 'PRIMARY KEY'
    // WHERE
    //     c.table_schema = 'public'
    // ORDER BY
    //     c.table_name, c.ordinal_position;`


     "dev": "nodemon --exec \"node --inspect -r ts-node/register\" src/main_index.ts",



      // let targetRow = _res.rows[0]//
    // let _relateData = data['_relateData'] //关联数据
    // if (_relateData != null && typeof _relateData == 'object') {
    //   for (const [key, object] of Object.entries(_relateData)) {
    //     let dTableName = key //子表表名
    //     let _obj = object as any
    //     let data = _obj.data || []
    //     let required = _obj.required //是否必须有数据
    //     if (data.length == 0 && required == true) {
    //       throw new errors.BadRequest(`子表${dTableName}必须有数据`) //
    //     }
    //     await this._createDetailData({ data: data, mainRow: targetRow, tableName: dTableName }, params) //
    //   }
    // }