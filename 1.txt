let createTransformer = {
    password: async (value: any, data: any, context: HookContext) => {
        const { app, params } = context
        let options = { strategy: 'local', authentication: 'jwt' }//
        const { strategy = 'local' } = options
        //@ts-ignore
        const authService = app!.defaultAuthentication(options.authentication)
        const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]
        if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
            throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
        }
        let field = authService.configuration.local?.passwordField || 'password'
        let addHashedPassword = async (data: any) => {
            const password = get(data, field)
            if (password === undefined) {
                debug(`hook.data.${field} is undefined, not hashing password`)
                throw new BadRequest(`hook.data.${field} is undefined, not hashing password`)
            }
            const hashedPassword: string = await localStrategy.hashPassword(password, params)
            let d1 = set(cloneDeep(data), field, hashedPassword)
            return d1
        }
        let rData = await addHashedPassword(data)
        context.data = rData
    }
}


export default function hashPassword(field: string, options: HashPasswordOptions = {}) {
    if (!field) {
        throw new Error('The hashPassword hook requires a field name option')
    }
    return async (context: HookContext, next?: NextFunction) => {
        const { app, data, params } = context

        if (data !== undefined) {
            //@ts-ignore
            const authService = app!.defaultAuthentication(options.authentication)
            const { strategy = 'local' } = options

            if (!authService || typeof authService.getStrategies !== 'function') {
                throw new BadRequest('Could not find an authentication service to hash password')
            }

            const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]

            if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
                throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
            }

            const addHashedPassword = async (data: any) => {
                const password = get(data, field)

                if (password === undefined) {
                    debug(`hook.data.${field} is undefined, not hashing password`)
                    return data
                }

                const hashedPassword: string = await localStrategy.hashPassword(password, params)

                return set(cloneDeep(data), field, hashedPassword)
            }
            context.data = Array.isArray(data)
                ? await Promise.all(data.map(addHashedPassword))
                : await addHashedPassword(data)
        }
        if (typeof next === 'function') {
            return next()
        }
    }
}





 hooks(this, {
            create: [
                async function (context: HookContext, next) {
                    // console.log(Object.keys(context), '111')//
                    // const data1 = context.data
                    // console.log(data1, 'testData')//
                    const { app, params, data } = context
                    let options = { strategy: 'local', authentication: 'authentication' }//
                    const { strategy = 'local' } = options
                    //@ts-ignore
                    const authService = app!.defaultAuthentication(options.authentication)
                    const [localStrategy] = authService.getStrategies(strategy) as LocalStrategy[]
                    if (!localStrategy || typeof localStrategy.hashPassword !== 'function') {
                        throw new BadRequest(`Could not find '${strategy}' strategy to hash password`)
                    }
                    let field = authService.configuration.local?.passwordField || 'password'
                    let addHashedPassword = async (data: any) => {
                        const password = get(data, field)
                        if (password === undefined) {
                            debug(`hook.data.${field} is undefined, not hashing password`)
                            throw new BadRequest(`hook.data.${field} is undefined, not hashing password`)
                        }
                        const hashedPassword: string = await localStrategy.hashPassword(password, params)
                        let d1 = set(cloneDeep(data), field, hashedPassword)
                        return d1
                    }
                    let rData = await addHashedPassword(data)
                    context.data = rData
                    await next()
                }
            ]
        })


        "dev": "nodemon --exec \"node --inspect-brk -r ts-node/register\" src/main_index.ts"


        // const params = context.params || {}
            // const provider = params.provider
            // if (provider) {
            //   let adadpter = params.adapter
            //   if (adadpter == null) {
            //     params.adapter = {}
            //     adadpter = params.adapter
            //   }
            //   let Model = adadpter.Model
            //   let oldModel = this.getOptions({}).Model
            //   if (Model == null) {
            //     let transaction = await oldModel.transaction()
            //     adadpter.Model = transaction
            //   }
            // }//

            //     let sql = `SELECT

    // 		c.*,
    //     CASE
    //         WHEN tc.constraint_type = 'PRIMARY KEY' THEN true
    //         ELSE false
    //     END AS is_primary_key
    // FROM
    //     information_schema.columns c
    // LEFT JOIN information_schema.key_column_usage kcu
    //     ON c.table_name = kcu.table_name
    //     AND c.column_name = kcu.column_name
    //     AND c.table_schema = kcu.table_schema
    // LEFT JOIN information_schema.table_constraints tc
    //     ON kcu.constraint_name = tc.constraint_name
    //     AND kcu.table_schema = tc.table_schema
    //     AND tc.constraint_type = 'PRIMARY KEY'
    // WHERE
    //     c.table_schema = 'public'
    // ORDER BY
    //     c.table_name, c.ordinal_position;`


     "dev": "nodemon --exec \"node --inspect -r ts-node/register\" src/main_index.ts",



      // let targetRow = _res.rows[0]//
    // let _relateData = data['_relateData'] //ÂÖ≥ËÅîÊï∞ÊçÆ
    // if (_relateData != null && typeof _relateData == 'object') {
    //   for (const [key, object] of Object.entries(_relateData)) {
    //     let dTableName = key //Â≠êË°®Ë°®Âêç
    //     let _obj = object as any
    //     let data = _obj.data || []
    //     let required = _obj.required //ÊòØÂê¶ÂøÖÈ°ªÊúâÊï∞ÊçÆ
    //     if (data.length == 0 && required == true) {
    //       throw new errors.BadRequest(`Â≠êË°®${dTableName}ÂøÖÈ°ªÊúâÊï∞ÊçÆ`) //
    //     }
    //     await this._createDetailData({ data: data, mainRow: targetRow, tableName: dTableName }, params) //
    //   }
    // }


    // app.hooks({
  //   all: [
  //     async (context: HookContext, next: any) => {
  //       //
  //       // console.log(context.service.serviceName, 'testName')//
  //       await next()
  //       let params = context.params || {}
  //       let provider = params.provider
  //       if (provider == 'socketio') {
  //         ////
  //         context.result = {
  //           data: context.result,
  //           code: 200
  //         } //
  //       }
  //     }
  //   ]
  // })//


   let hooksMetaData = service.hooksMetaData
    if (hooksMetaData != null && Array.isArray(hooksMetaData)) {
      for (const hook of hooksMetaData) {
        hooks(service, hook)
      }
    }
    //@ts-ignore
    let routes = service.routes || [] //
    //@ts-ignore
    let routesMethods = routes.map(route => route.path)
    //@ts-ignore
    let ts = app.use(p, service, {
      //@ts-ignore
      methods: [...defaultServiceMethods, ...routesMethods], // //
      koa: {
        before: [
          async (context: FeathersKoaContext, next: NextFunction) => {
            await next()
          }
        ],
        after: [
          async (context: FeathersKoaContext, next: NextFunction) => {
            await next() ////
            const response = context.response
            response.body = {
              data: response.body,
              code: 200
            } //
          }
        ]
      }
    })


    let hooksMetaData = service.hooksMetaData
    if (hooksMetaData != null && Array.isArray(hooksMetaData)) {
      for (const hook of hooksMetaData) {
        hooks(service, hook)
      }
    }
    let routes = service.routes || [] //
    let routesMethods = routes.map(route => route.path) //
    //@ts-ignore
    let ts = app.use(p, service, {
      //@ts-ignore
      methods: [...defaultServiceMethods, ...routesMethods], // //
      koa: {
        before: [
          async (context: FeathersKoaContext, next: NextFunction) => {
            await next()
          }
        ]
      }
    })
    ts.hooks({
      around: {
        all: [
          async (context: HookContext, next) => {
            await next()
          }
        ]
      }
    })

    // const service = new AppAuthService(app)
  // let jwtStarategy = new JWTStrategy()
  // let localStrategy = new LocalStrategy()
  // service.register('jwt', jwtStarategy)
  // service.register('local', localStrategy)
  // app.use('authentication', service)


   // let _node = {
    //   ...this.createIdKey('inline'),
    //   columns: [
    //     {
    //       ...this.createIdKey('grid'),
    //       options: {
    //         gutter: 0,
    //         justify: 'start',
    //         align: 'top'
    //       },
    //       style: {
    //         width: '100%'
    //       },
    //       columns: [
    //         {
    //           ...this.createIdKey('col'), //
    //           // list: [_.cloneDeep(node)],
    //           list: [
    //             {
    //               ...this.createIdKey('inline'),
    //               columns: lastList
    //             }
    //           ],
    //           options: {
    //             span: 24,
    //             offset: 0,
    //             push: 0,
    //             pull: 0,
    //             style: {}
    //           }
    //         }
    //       ]
    //     }
    //   ]
    // }


     // let res = lastList //
    // let btnRow=createNodeGrid()
    // let res1 = this.getLastNodeInLayout(config.layout.mobile)
    // res[0] = config.fields[0].id //
    // res1.forEach((item, i) => {
    //   let _field = config.fields[i]
    //   if (_field) {
    //     item.columns.push(_field.id) //
    //   }
    // }) //

     // let _config = await _this.getTableConfig(tableName)
                  // let options = f?.options //
                  // if (options == null) {
                  //   options = {}
                  //   f.options = options
                  // }
                  // let oldColumns = options?.columns


                  
  // @useMethodTransform({
  //   //@ts-ignore
  //   password: createPasswordTransform()
  // })
  // @useCaptCha({})



  // let fn = function escapeSqlString(value: string): string {
    //   if (typeof value !== 'string') return value as any

    //   return value
    //   // .replace(/\\/g, '\\\\') // ÂèçÊñúÊù† ‚Üí ÂèåÂèçÊñúÊù†
    //   // .replace(/'/g, "''") // ÂçïÂºïÂè∑ ‚Üí ‰∏§‰∏™ÂçïÂºïÂè∑ÔºàÊ†áÂáÜ SQL ËΩ¨‰πâÔºâ
    //   // .replace(/\u0000/g, '') // NULL Â≠óÁ¨¶ÔºàPostgres/SQLite ‰∏çÂÖÅËÆ∏Ôºâ
    //   // .replace(/\x08/g, '') // BackspaceÔºàMySQL ÂèØËÉΩËØØËß£ÈáäÔºâ
    //   // .replace(/\x09/g, '\\t') // Tab
    //   // .replace(/\x0A/g, '\\n') // LF
    //   // .replace(/\x0D/g, '\\r') // CR
    //   // .replace(/\x1a/g, '') // Ctrl+ZÔºåMySQL ÁâπÊÆäÂê´‰πâ
    // }
    // let rSql = sqlArr
    //   .map(s => {
    //     let s1 = fn(s)
    //     return s1 //
    //   })
    //   .join(';')
    // let allV = buildArr.flat(1)
    // await this.db(params).raw(rSql, allV) // //

    if (Array.isArray(oldColumns)) {
                    // oldColumns.forEach((col: any) => {
                    //   //Êúâ‰ªÄ‰πàÈúÄË¶ÅÂêàÂπ∂ÁöÑÂë¢
                    //   let f = col.filed
                    //   let nColumns = _config?.columns || []
                    //   let tCol = nColumns.find((col: any) => col.field == f)
                    //   if (tCol) {
                    //     Object.entries(tCol).forEach(([key, value]) => {
                    //       if (['title', 'order', 'hidden', 'formatFn'].includes(key)) {
                    //         //
                    //         return
                    //       } //
                    //       col[key] = value
                    //     })
                    //   }
                    // })
                  } //

                  // console.log(query, context.result, 'query') //
      //@ts-ignore
      // console.log(_this.hooksMetaData) //


      //let items: any = await this._findOrGet(null, updateParams)
    // if (id !== null) {
    //   if (items.length === 1) {
    //     return items[0]
    //   } else {
    //     throw new errors.NotFound(`No record found for id '${id}'`)
    //   }
    // }

    // return items
    // return resArr 




    "postgresql": {
    "client": "pg",
    "connection": "postgres://postgres:123456789sike@47.92.84.152:5432/platform_2"
  },
  "appDb": {
    "client": "pg",
    "connection": "postgres://postgres:123456@localhost:5432/erp"
  },
  "defaultConnection": {
    "client": "pg",
    "connection": "postgres://postgres:123456789sike@47.92.84.152:5432/platform_2"
  },




   "postgresql": {
    "client": "pg",
    "connection": "postgres://postgres:123456789sike@47.92.84.152:5432/platform_2"
  },
  "appDb": {
    "client": "pg",
    "connection": "postgres://postgres:123456@localhost:5432/erp"
  },
  "defaultConnection": {
    "client": "pg",
    "connection": "postgres://postgres:123456789sike@47.92.84.152:5432/platform_2"
  },


    "postgresql": {
    "client": "pg",
    "connection": "postgres://postgres:123456@localhost:5432/platform"
  },
  "appDb": {
    "client": "pg",
    "connection": "postgres://postgres:123456@localhost:5432/erp"
  },
  "defaultConnection": {
    "client": "pg",
    "connection": "postgres://postgres:123456@localhost:5432/platform"
  },

      // for (const dRow of data) {
    //   dRow[relateKey] = mainRow[relateMainKey] //////
    //   params.getMainParam = () => params
    //   let _res = await s.batchUpdate(dRow, params) //
    //   arr1.push(_res) //
    // }


     let app = this.app
    let sql1 = `SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE datname = '${appName}'
  AND pid <> pg_backend_pid();` //
    let pgClient = app.get('postgresqlClient') //
    await pgClient.raw(sql1)
    let _key = `${appName}_${userid}` //
    let sql = `CREATE DATABASE ${_key}
    WITH 
    OWNER = postgres
    TEMPLATE = ${appName};` //
    await pgClient.raw(sql) //


     let client: Knex = this.get('postgresqlClient')
    let name = config.name //ÂàõÂª∫ÂÖ¨Âè∏
    let companies = await client('company').where('name', name).select() //
    if (companies.length === 0) {
      let connection = config.connection
      let type = config.type
      if (connection == null) {
        return
      }
      let _client = knex({
        client: type,
        connection: connection
      })
      await client('company').insert(config) //
    }

    let app = this.app
    await app.createCompany({
      appName,
      userId: userid //
    })

     // let allServices = arr //
    // for (const obj of allServices) {
    //   const p: string = obj.path //Ë£ÖÈ•∞
    //   const service = obj.service
    //   //@ts-ignore
    //   service.initHooks(app) //
    // }

    // io.emit = function (...args) {
            //   console.log(...args, 'sfsdfjsdfsd') //
            //   oldEmit.call(io, ...args)
            // }
            // let oldSend = io.send
            // //@ts-ignore
            // io.send = function (...args) {
            //   console.log(...args)
            //   oldSend.call(io, ...args)
            // }

            // if (id !== null) {
    //   if (items.length === 1) {
    //     return items[0]
    //   }
    //   throw new errors.NotFound(`No record found for id '${id}'`)
    // }
    // return items

    //   let res: any = context.result
      //   let rows = res
      //   for (const item of rows) {
      //     //
      //     let tableName = item.tableName
      //     let app: myFeathers = context.app
      //     let colS: TableService = app.service('columns') as any
      //     let _this = colS
      //     let allTable = await app.getCompanyTable(_this.getCompanyId(), _this.getAppName())
      //     let tTable = allTable[tableName]
      //     if (tTable != null) {
      //       let columns = JSON.parse(JSON.stringify(tTable.columns || [])) //
      //       columns.forEach((col: any) => {
      //         let nullable = col.nullable
      //         if (nullable == false) {
      //           col.nullable = '0'
      //         } else {
      //           col.nullable = '1' //
      //         }
      //       })
      //       await colS.create(columns, {}) //
      //     }
      //   } //

       //Ê∑ªÂä†Âàó
          /* 
            {
    name: 'iNstructionsCode',
    tableID: 180522,
    columnID: 62,
    dataTypeID: 1043,
    dataTypeSize: -1,
    dataTypeModifier: -1,
    format: 'text'
  }
          */
          //   console.log(data.fields)

          // "authentication": {
    //   "strategy": "local",
    //   "payload": {
    //     "iat": 1745995936,//
    //     "exp": 1746082336,
    //     "aud": "https://yourdomain.com",
    //     "sub": "1",
    //     "jti": "6ecb02bd-a0de-428e-9688-afe391abe1e1"
    //   }
    // },
    // "user": {
    //   "id": 1,
    //   "createdAt": "2025-04-30T06:52:03.149Z",
    //   "updatedAt": "2025-04-30T06:52:03.149Z",
    //   "username": "1",
    //   "email": "1",
    //   "password": "$2b$10$gVfIaJyDH.Fqbn5.fnOKSuNpfKSfjV.61ER/Top/kVqyByh/kmqFy",
    //   "companyid": null,
    //   "appName": null
    // }


      // let columnInfo = this.columnInfo.map(item => item.field)
      // if (columnInfo.includes(id)) {
      // } else {
      //   this.isView = true
      // }

      // let allTableName = result.map(row => {
        //   return row.viewName
        // })
        // let reColumns: any[] = await colService.find({
        //   query: {
        //     tableName: {
        //       $in: allTableName
        //     }
        //   }
        // })
        // let tableObj = reColumns.reduce((res: any, item: any) => {
        //   let tableName = item.tableName
        //   let t = res[tableName]
        //   if (t == null) {
        //     res[tableName] = []
        //     t = res[tableName]
        //   }
        //   t.push(item)
        //   return res
        // }, {})
        // result.forEach(res => {
        //   let tableName = res.tableName
        //   res['columns'] = tableObj[tableName] //
        // })


        //@ts-ignore
        // let service: TableService = app.service('tables')
        // let tableName = query.tableName
        // if (tableName != null) {
        //   let res = await service.saveDefaultTableInfo(tableName) //
        //   context.result = res //
        // }

        // let allD = await this.find({
    //   query: {
    //     $or: _qArr
    //   }
    // })
    // console.log(allD, 'testArr') //
    // return allD 

    // const PUBLISHERS = Symbol.for('@feathersjs/transport-commons/publishers')
// const CHANNELS = Symbol.for('@feathersjs/transport-commons/channels')
// const ALL_EVENTS = Symbol.for('@feathersjs/transport-commons/all-events')

// export const keys = {
//   PUBLISHERS: PUBLISHERS as typeof PUBLISHERS,
//   CHANNELS: CHANNELS as typeof CHANNELS,
//   ALL_EVENTS: ALL_EVENTS as typeof ALL_EVENTS
// }
// console.log(keys,'sfsfsfs')//

 // console.log(Object.keys(params), 'testP') //
    // console.log(params.authentication, 'testA') //

    // let auth = {
  //   accessToken:
  //     'eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NDU5OTU5MzYsImV4cCI6MTc0NjA4MjMzNiwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsInN1YiI6IjEiLCJqdGkiOiI2ZWNiMDJiZC1hMGRlLTQyOGUtOTY4OC1hZmUzOTFhYmUxZTEifQ.Cs7Xv7nlY_DdGEN-adgUhPouwzImGH10jRg5K4clars',
  //   strategy: 'jwt'
  // }
  // socket.feathers = {
  //   provider: 'socketio',
  //   headers: socket.handshake.headers,
  //   authentication: {
  //     strategy: 'jwt',
  //     accessToken:
  //       'eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NDYyNjM0MjAsImV4cCI6MTc0NjM0OTgyMCwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsInN1YiI6IjEiLCJqdGkiOiIxZjEzOTRhZi1hODA4LTQzMTAtYTM1OS1jNmJlNmJkYTU3Y2QifQ.QydhEx5Q3TX0rauXbb_QEB8puf0Tkse4W0Jopr81McE'
  //   }
  // }
  // console.log(socket.handshake.auth,'sjfksfjslkfs')//

  // let isView = false
      // let id = 'id'
      // let ids = [] //
      // let _t = allT[name]
      // if (_t) {
      //   let _isView = _t.isView
      //   if (_isView == true) {
      //     isView = true
      //   }
      //   let primaryKey = _t.columns.filter((col: any) => col['is_primary_key'] == true)
      //   ids = primaryKey.map((col: any) => col['column_name'])
      //   // console.log(name, ids)//
      //   if (ids.length > 0) {
      //     let _key = primaryKey[0]['column_name']
      //     id = _key
      //   } else {
      //     console.log('Ë°®Ê†ºÊ≤°Êúâ‰∏ªÈîÆÂ≠óÊÆµ', name, ids) ////
      //   }
      // }
      // let opt = {
      //   serviceName: name,
      //   id,
      //   ids,
      //   isView
      // }

      // export function getDispatcher(emit: string, socketMap: WeakMap<RealTimeConnection, any>, socketKey?: any) {
//   return function (event: string, channel: CombinedChannel, context: HookContext, data?: any) {
//     channel.connections.forEach(connection => {
//       // The reference between connection and socket is set in `app.setup`
//       const socket = socketKey ? connection[socketKey] : socketMap.get(connection)

//       if (socket) {
//         const eventName = `${context.path || ''} ${event}`.trim()

//         let result = channel.dataFor(connection) || context.dispatch || context.result

//         // If we are getting events from an array but try to dispatch individual data
//         // try to get the individual item to dispatch from the correct index.
//         if (!Array.isArray(data) && Array.isArray(context.result) && Array.isArray(result)) {
//           result = result.find(resultData => isEqual(resultData, data))
//         }
//         console.log(eventName, 'testEventName') //
//         socket[emit](eventName, result)
//       }else{
//         console.log('Êâæ‰∏çÂà∞socket12123')
//       }
//     })
//   }
// }

// if (this.io) {
          //   resolve(this.io)
          // } else {
          //   reject('Êâæ‰∏çÂà∞Áà∂Á∫ßIOÂÆû‰æã')
          // }

            // console.log(tpath)
      // mainApp?.use(tpath, ts)//
      // console.log(ts)//
      // console.log(pre)//
      // mainApp?.use(pre, ts)


      export async function createNewApp(app: myFeathers, config: any) {
  let knexErp1: any = null
  let appName = config.appName || 'erp' //
  let userId = config.userId || parseInt((Math.random() * 100).toFixed(0)) //
  //Ëøô‰∏™ÊòØÁÆ°ÁêÜÂëòÊï∞ÊçÆÂ∫ì
  let knexDefault = app.getMainApp()?.get('defaultConnection')
  // 2. knexErpÔºöËøûÊé•Âà∞ÂéüÂßãÊï∞ÊçÆÂ∫ì erpÔºåËØªÂèñË°®ÁªìÊûÑ
  const knexErp = app.getMainApp()?.get(`${appName}Connection`)
  if (!knexErp) {
    throw new errors.BadGateway('Ê≤°ÊúâÊâæÂà∞appÁöÑÊï∞ÊçÆÂ∫ì') //
  }
  try {
    console.log('üîç Ê≠£Âú®‰ªé erp Êï∞ÊçÆÂ∫ìËØªÂèñÊâÄÊúâË°®Âêç‚Ä¶‚Ä¶')
    const tables = await knexErp('information_schema.tables')
      .select('table_schema', 'table_name')
      .where({
        table_catalog: 'erp', // Êï∞ÊçÆÂ∫ìÂêçÂ≠ó
        table_type: 'BASE TABLE'
      })
      //@ts-ignore
      .andWhereNot('table_schema', 'pg_catalog')
      .andWhereNot('table_schema', 'information_schema')

    if (tables.length === 0) {
      console.log('‚ö†Ô∏è erp Â∫ìÈáåÊ≤°ÊúâÂèØÁî®ÁöÑÁî®Êà∑Ë°®ÔºåÈÄÄÂá∫„ÄÇ')
      process.exit(1) //
    }
    // ÁªìÊûúÁ§∫‰æãÔºö[{ table_schema: 'public', table_name: 'users' }, { table_schema: 'public', table_name: 'orders' }, ‚Ä¶]
    console.log(`‚úÖ ÊâæÂà∞ ${tables.length} Âº†Ë°®„ÄÇ`)
    ////
    // ÂØπÊØèÂº†Ë°®ÔºåÂàÜÂà´ËØªÂèñÂàó‰ø°ÊÅØÂíåÂÆÉ‰ª¨ÁöÑ‰∏ªÈîÆÂàó//
    const schemaInfo: any = {} // { 'public.users': { columns: [...], primaryKeys: [...] }, ‚Ä¶ }
    //
    for (const { table_schema, table_name } of tables) {
      const fullName = `${table_schema}.${table_name}`
      // ËØªÂèñÊâÄÊúâÂàó‰ø°ÊÅØ
      const columns = await knexErp('information_schema.columns')
        .select(
          'column_name',
          'data_type',
          'is_nullable',
          'column_default',
          'character_maximum_length',
          'numeric_precision',
          'numeric_scale'
        )
        .where({
          table_catalog: 'erp',
          table_schema: table_schema,
          table_name: table_name
        })
        .orderBy('ordinal_position', 'asc')

      // ËØªÂèñ‰∏ªÈîÆ‰ø°ÊÅØÔºöÊü• information_schema.table_constraints + key_column_usage
      const pkResult = await knexErp('information_schema.table_constraints as tc')
        .join('information_schema.key_column_usage as kcu', function (this: any) {
          //
          this.on('tc.constraint_name', '=', 'kcu.constraint_name')
            .andOn('tc.table_schema', '=', 'kcu.table_schema')
            .andOn('tc.table_name', '=', 'kcu.table_name')
        })
        .select('kcu.column_name')
        .where({
          'tc.table_catalog': 'erp',
          'tc.table_schema': table_schema,
          'tc.table_name': table_name,
          'tc.constraint_type': 'PRIMARY KEY'
        })

      const primaryKeys = pkResult.map((r: any) => r.column_name)
      //@ts-ignore
      schemaInfo[fullName] = {
        columns,
        primaryKeys
      }
      console.log(`  ‚Ä¢ Â∑≤ËØªÂèñË°® ${fullName}ÔºåÂÖ± ${columns.length} ÂàóÔºå‰∏ªÈîÆÂàóÔºö${primaryKeys.join(', ')}`)
    }

    // --------------------------
    // Ôºà‰∏âÔºâStep3ÔºöÂú®ÈªòËÆ§Â∫ìÈáåÂÖàÂàõÂª∫ erp_1 Êï∞ÊçÆÂ∫ìÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
    // --------------------------
    console.log('\nüèó ÂáÜÂ§áÂàõÂª∫Êñ∞Êï∞ÊçÆÂ∫ì erp_1ÔºàÂ¶ÇÊûúÂ∞ö‰∏çÂ≠òÂú®Ôºâ‚Ä¶‚Ä¶')

    // ÂÖàÊü•‰∏Ä‰∏ã pg_databaseÔºåÈÅøÂÖçÈáçÂ§çÂàõÂª∫
    const exists = await knexDefault('pg_database').select('datname').where({ datname: 'erp_1' }).first()

    if (!exists) {
      console.log('   ‚Üí erp_1 Êï∞ÊçÆÂ∫ì‰∏çÂ≠òÂú®ÔºåÊ≠£Âú®ÂàõÂª∫‚Ä¶‚Ä¶')
      await knexDefault.raw('CREATE DATABASE erp_1;')
      console.log('‚úÖ ÊàêÂäüÂàõÂª∫ erp_1 Êï∞ÊçÆÂ∫ì„ÄÇ')
    } else {
      console.log('   ‚Üí erp_1 Êï∞ÊçÆÂ∫ìÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫Ê≠•È™§„ÄÇ')
    }

    // --------------------------
    // ÔºàÂõõÔºâStep4ÔºöÂàùÂßãÂåñ knexErp1 ËøûÊé•Âà∞Êñ∞Â∫ì erp_1
    // --------------------------
    console.log('\nüîå ËøûÊé•Âà∞Êñ∞Êï∞ÊçÆÂ∫ì erp_1‚Ä¶‚Ä¶')
    knexErp1 = Knex({
      client: 'pg',
      connection: {
        host: 'localhost',
        user: 'postgres',
        password: '123456',
        database: 'erp_1',
        port: 5432
      },
      pool: { min: 0, max: 7 }
    })
    // --------------------------
    // Ôºà‰∫îÔºâStep5ÔºöÈÅçÂéÜ schemaInfoÔºåÈÄêÂº†Âú® erp_1 ‰∏≠Âª∫Ë°®
    // --------------------------
    console.log('\nüöß ÂºÄÂßãÂú® erp_1 ‰∏≠ÂàõÂª∫Ë°®‚Ä¶‚Ä¶')

    // ‚Ä¶ÔºàÂâçÈù¢Â∑≤ÊåâÂéüËÑöÊú¨ÂÆåÊàêÔºöËøûÊé• knexDefault, knexErpÔºåËØªÂá∫ schemaInfo Á≠âÔºâ‚Ä¶

    // ÂÅáËÆæÂ∑≤ÁªèÂàáÊç¢Âà∞ erp_1ÔºåÂπ∂Êúâ knexErp1Ôºö
    for (const fullName of Object.keys(schemaInfo)) {
      const { columns, primaryKeys } = schemaInfo[fullName]
      const [schema, tableName] = fullName.split('.')

      if (schema !== 'public') {
        console.log(`Ë∑≥Ëøá schema ${schema} ‰∏ãÁöÑË°® ${tableName}ÔºàÁ§∫‰æã‰ªÖÂ§ÑÁêÜ publicÔºâ`)
        continue
      }

      // Â¶ÇÊûúË°®Â∑≤Â≠òÂú®ÔºåÂàôÂÖà drop
      if (await knexErp1.schema.withSchema(schema).hasTable(tableName)) {
        await knexErp1.schema.withSchema(schema).dropTable(tableName)
      } //
      // Âú® erp_1 ‰∏≠ÈáçÂª∫Ë°®
      await knexErp1.schema.withSchema(schema).createTable(tableName, (table: any) => {
        for (const col of columns) {
          const {
            column_name,
            data_type,
            is_nullable,
            column_default,
            character_maximum_length,
            numeric_precision,
            numeric_scale
          } = col

          let colBuilder

          // ‚Äî‚Äî Ê£ÄÊµãÊòØÂê¶ÊòØ SERIAL / Ëá™Â¢ûÂàó ‚Äî‚Äî
          if (column_default && column_default.startsWith('nextval(')) {
            // Áõ¥Êé•Áî® .increments()ÔºàKnex ‰ºöËá™Âä®ÂàõÂª∫ sequence + ÈªòËÆ§ÂÄºÔºâ
            colBuilder = table.increments(column_name)
          } else {
            // ‚Äî‚Äî ÊôÆÈÄöÁ±ªÂûã ‚Äî‚Äî
            switch (data_type) {
              case 'integer':
                colBuilder = table.integer(column_name)
                break
              case 'smallint':
                colBuilder = table.specificType(column_name, 'smallint')
                break
              case 'bigint':
                colBuilder = table.bigInteger(column_name)
                break
              case 'character varying':
              case 'varchar':
                if (character_maximum_length) {
                  colBuilder = table.string(column_name, character_maximum_length)
                } else {
                  colBuilder = table.string(column_name)
                }
                break
              case 'character':
              case 'char':
                if (character_maximum_length) {
                  colBuilder = table.specificType(column_name, `char(${character_maximum_length})`)
                } else {
                  colBuilder = table.specificType(column_name, `char(1)`)
                }
                break
              case 'text':
                colBuilder = table.text(column_name)
                break
              case 'boolean':
                colBuilder = table.boolean(column_name)
                break
              case 'date':
                colBuilder = table.date(column_name)
                break
              case 'timestamp without time zone':
              case 'timestamp with time zone':
                colBuilder = table.timestamp(column_name)
                break
              case 'double precision':
              case 'real':
              case 'numeric':
              case 'decimal':
                if (numeric_precision != null && numeric_scale != null) {
                  colBuilder = table.decimal(column_name, numeric_precision, numeric_scale)
                } else {
                  colBuilder = table.decimal(column_name)
                }
                break
              case 'json':
              case 'jsonb':
                colBuilder = table.specificType(column_name, data_type)
                break
              case 'uuid':
                colBuilder = table.uuid(column_name)
                break
              case 'bytea':
                colBuilder = table.binary(column_name)
                break
              default:
                console.warn(`‚ö†Ô∏è Êú™ËØÜÂà´ÁöÑÊï∞ÊçÆÁ±ªÂûã "${data_type}"Ôºå‰ΩøÁî® specificType`)
                colBuilder = table.specificType(column_name, data_type)
            }

            // ËÆæÁΩÆ NOT NULL / NULL
            if (is_nullable === 'NO') {
              colBuilder.notNullable()
            } else {
              colBuilder.nullable()
            }

            // Â¶ÇÊûúÊúâÈªòËÆ§ÂÄºÔºà‰∏îÂπ∂Èùû nextval‚Ä¶ÔºâÔºåÂ∞±ÂéüÊ†∑ÂÜôÂÖ•
            if (column_default !== null) {
              colBuilder.defaultTo(knexErp1.raw(column_default))
            }
          }
        }

        // ‰∏ªÈîÆÁ∫¶Êùü
        if (primaryKeys.length > 0) {
          table.primary(primaryKeys)
        }
      })

      console.log(`Ë°® ${schema}.${tableName} Â∑≤ÂàõÂª∫„ÄÇ`)
    }

    console.log('\nüéâ ÊâÄÊúâË°®ÁªìÊûÑÂ∑≤ÊàêÂäüÂêåÊ≠•Âà∞ erp_1 Êï∞ÊçÆÂ∫ìÔºÅ')
  } catch (err) {
    console.error('‚ùå ËøáÁ®ãÂá∫Áé∞ÈîôËØØÔºö', err)
  } finally {
    // ÊúÄÂêéÂÖ≥Èó≠ÊâÄÊúâ Knex ËøûÊé•
    await knexErp.destroy()
    await knexDefault.destroy()
    if (knexErp1) {
      await knexErp1.destroy()
    }
    process.exit(0)
  }
}
let obj = {
  provider: 'socketio',
  headers: {
    host: 'localhost:3031',
    connection: 'Upgrade',
    pragma: 'no-cache',
    'cache-control': 'no-cache',
    'user-agent':
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0',
    upgrade: 'websocket',
    origin: 'http://localhost:3003',
    'sec-websocket-version': '13',
    'accept-encoding': 'gzip, deflate, br, zstd',
    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,fr;q=0.5',
    cookie:
      'session=U2FsdGVkX1/8m7tAhv2rq4Pbjsd8DSbsri1CXZ3/DrkZ6xv/YGE1bbXA5gosoyewwOyoHKvqmvgKOrhcWetEn8hw7P8nOxCE1QuIIdo6bY07MOCnERli9o5lpoOGozUB/x4XbJmg3UApx5guO+cX/g==; Hm_lvt_52eb07460b7dc3e27bb80c78c0988671=1743073927',
    'sec-websocket-key': 'nNcGSegcHH6Xz4eFSp4D0A==',
    'sec-websocket-extensions': 'permessage-deflate; client_max_window_bits',
    authorization:
      'eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NTAwNDc3MjQsImV4cCI6MTc1MDEzNDEyNCwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsInN1YiI6IjEiLCJqdGkiOiJiM2Q3ODZhOC0wNTQ4LTRkZGMtYTIyYS00NTc4Y2RjZGUxN2YifQ.f0nLDh680HhW0MyK-Nrz_aEgmTG1QovFqx_1GvUgh0Q'
  },
  authentication: {
    strategy: 'jwt',
    accessToken:
      'eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NTAwNDc3MjQsImV4cCI6MTc1MDEzNDEyNCwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsInN1YiI6IjEiLCJqdGkiOiJiM2Q3ODZhOC0wNTQ4LTRkZGMtYTIyYS00NTc4Y2RjZGUxN2YifQ.f0nLDh680HhW0MyK-Nrz_aEgmTG1QovFqx_1GvUgh0Q',
    authentication: {
      strategy: 'jwt',
      accessToken:
        'eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NTAwNDc3MjQsImV4cCI6MTc1MDEzNDEyNCwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsInN1YiI6IjEiLCJqdGkiOiJiM2Q3ODZhOC0wNTQ4LTRkZGMtYTIyYS00NTc4Y2RjZGUxN2YifQ.f0nLDh680HhW0MyK-Nrz_aEgmTG1QovFqx_1GvUgh0Q',
      payload: [Object]
    },
    user: {
      id: 1,
      createdAt: '2025-05-24 09:13:24',
      updatedAt: '2025-05-24 09:13:24',
      username: 'dxf',
      email: '1151685410@qq.com',
      password: '$2b$10$mtmxQd1lFzh6ORBsVOsfvOzH2XN107xINOtc3AmggeDO9.CfXztXm',
      appName: null,
      companyName: 'newC',
      companyCnName: 'Êñ∞ÂÖ¨Âè∏',
      companyType: null,
      companyId: null,
      phone: null,
      avatar: '/images/7332066ce14ee350ac57f9d74393a604d7c7ba4fdd3e15f3a47daa59bbc647f9.jpg',
      companyLogo: '/images/7332066ce14ee350ac57f9d74393a604d7c7ba4fdd3e15f3a47daa59bbc647f9.jpg'
    }
  }
}


// console.log(params,'testP')//
    // console.log(userid)
    // return userid || '123' //